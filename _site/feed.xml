<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>i</title>
    <description>Welcome to my blog!</description>
    <link>http://haroel.github.io/i/</link>
    <atom:link href="http://haroel.github.io/i/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 14 Jul 2015 15:13:42 +0800</pubDate>
    <lastBuildDate>Tue, 14 Jul 2015 15:13:42 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>经典算法总结</title>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1 取平方根 ` 作者：约翰-卡马克`&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; float Q_rsqrt( float number )
 {
     long i;
     float x2, y;
     const float threehalfs = 1.5F;
     x2 = number * 0.5F;
     y   = number;
     i   = * ( long * ) &amp;amp;y;   // evil floating point bit level hacking
     i   = 0x5f3759df - ( i &amp;gt;&amp;gt; 1 ); // what the fuck?
     y   = * ( float * ) &amp;amp;i;
     y   = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration
     // y   = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed

     #ifndef Q3_VM
     #ifdef __linux__
      assert( !isnan(y) ); // bk010122 - FPE?
     #endif
     #endif
     return y;
 }  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2 绝对值 ` 作者：约翰-卡马克`&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  float Q_fabs( float f ) 
  {
      int tmp = * ( int * ) &amp;amp;f;
      tmp &amp;amp;= 0x7FFFFFFF;
      return * ( float * ) &amp;amp;tmp;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3 不用临时变量交换两个数的值&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  a = a ^ b;
  b = b ^ a;
  a = a ^ b;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4 求最大公约数&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  int gcd(int x,int y)
  { 
      return y?gcd(y,x%y):x; 
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 14 Jul 2015 21:09:00 +0800</pubDate>
        <link>http://haroel.github.io/i/%E7%AE%97%E6%B3%95/2015/07/14/cpp%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://haroel.github.io/i/%E7%AE%97%E6%B3%95/2015/07/14/cpp%E7%AC%94%E8%AE%B0.html</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>c++ 读取并解析excel文件方法</title>
        <description>&lt;p&gt;如转发还请注明出处，感谢。&lt;/p&gt;

&lt;p&gt;用Cocos开发模型特效工具编辑器，跨Mac和windows，当中有个需求是读取并解析excel文件，但网上的查找的例子几乎都只能是在windows下面使用，再或者是命令行脚本之类的。于是，自己写了一个非常轻量级的excel解析代码，纯cpp，除了依赖几个cocos2d 方法（zip解压和tinyxml2解析库），不依赖任何系统API。  目前只能解析常见的表式结构（如果把excel当成word文档使用就别看下面了），分享给大家，&lt;/p&gt;

&lt;p&gt;为了保证mac和windows都可以跑过，所以去掉注释，原谅我是VS菜鸟，当然代码够简单不写也能看懂。&lt;/p&gt;

&lt;p&gt;getSheetArray返回的是excel的 行数组 ，因为c++里面难以实现动态类结构，所以不得已写成这种方式，一般情况下该数据拿到后需要二次加工，你可以拿一个简单的excel表格（比如道具物品表），测试打个断点就知道有哪些数据结构。 我还有一个纯js版本的，适合cocos2d-js使用，待日后完善了再丢出来。&lt;/p&gt;

&lt;p&gt;Excel.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//基于com.lipi.excel as3 版本设计，感谢lipi的源码参考
// auto excel =  new Excel();
// bool result = excel-&amp;gt;parseExcelFile(filepath, 1);
// std::vector&amp;lt;LineInfo&amp;gt; arr = std::move( excel-&amp;gt;getSheetArray() );

#ifndef __ModelEditor__Excel__
#define __ModelEditor__Excel__

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;map&amp;gt;


struct LineInfo
{
    int lineIndex;
    std::vector&amp;lt;std::string&amp;gt; array;
};

class Excel
{
public:
    Excel();
    
    bool parseExcelFile(const std::string &amp;amp;filepath,int sheetIndex);
    
    std::vector&amp;lt;LineInfo&amp;gt; getSheetArray();
    
private:
    std::vector&amp;lt;std::string&amp;gt; _getValueArray();
private:
    std::map&amp;lt;int,LineInfo&amp;gt; excelHash;
    std::string _excelFilePath;
};

#endif /* defined(__ModelEditor__Excel__) */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Excel.cpp 实现部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
//  Excel.cpp
//
//  Created by howe on 15/5/5.
//  
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

#include &quot;Excel.h&quot;
#include &quot;cocos2d.h&quot;

#include &quot;external/tinyxml2/tinyxml2.h&quot;

using namespace tinyxml2;
using namespace std;

unsigned char* getFileDataFromZip(const std::string&amp;amp; zipFilePath, const std::string&amp;amp; filename, ssize_t *size)
{
    return cocos2d::FileUtils::getInstance()-&amp;gt;getFileDataFromZip(zipFilePath, filename, size);
}

void deleteNum( std::string &amp;amp;content)
{
    string::iterator t = content.begin();
    while(t != content.end())
    {
        if(*t &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; *t &amp;lt;= &#39;9&#39;)
        {
           content.erase(t);
        }
        else
        {
            t++;
        }
    }
}
int getColIndex(std::string &amp;amp;content)
{
    auto returnValue = 0;
    for (auto i =0; i &amp;lt; content.length(); i++)
    {
        char n = content[i];
        auto cValue = n - 64;
        returnValue *= 26;
        returnValue += cValue;
    }
    return returnValue - 1;
}

Excel::Excel()
:_excelFilePath(&quot;&quot;)
{
    
}

bool Excel::parseExcelFile(const std::string &amp;amp;ilepath, int sheetIndex)
{
    _excelFilePath = ilepath;
    excelHash.clear();
    
    char xml_file[256] = {0};
    sprintf(xml_file, &quot;xl/worksheets/sheet%d.xml&quot;,sheetIndex+1);
    ssize_t size;
    
    auto fileData = getFileDataFromZip(_excelFilePath, xml_file, &amp;amp;size);
    if (!fileData)
    {
        CCLOG(ilepath.c_str(), &quot;The excel file is not exist！&quot;);
        return false;
    }
    auto valueArray = std::move(_getValueArray());

    tinyxml2::XMLDocument doc;

    doc.Parse((const char*)fileData,size);
    
    XMLElement *root = doc.RootElement();
    
    XMLElement * sheetDataElement = root-&amp;gt;FirstChildElement(&quot;sheetData&quot;);
    XMLElement * rowElement =sheetDataElement-&amp;gt;FirstChildElement(&quot;row&quot;);
    
    while (rowElement)
    {
        LineInfo lineInfo;
        auto rowIndex = atoi(rowElement-&amp;gt;Attribute(&quot;r&quot;)) - 1;
        lineInfo.lineIndex = rowIndex;
        std::vector&amp;lt;std::string&amp;gt; &amp;amp;rowArray = lineInfo.array;
        auto cElement = rowElement-&amp;gt;FirstChildElement(&quot;c&quot;);
        while (cElement)
        {
            std::string cc = cElement-&amp;gt;Attribute(&quot;r&quot;);
            deleteNum(cc);
            auto colIndex  = getColIndex( cc );
            std::string t = &quot;&quot;;
            std::string v = &quot;&quot;;

            if (cElement-&amp;gt;Attribute(&quot;t&quot;))
            {
                t = cElement-&amp;gt;Attribute(&quot;t&quot;);
            }
            auto vElement = cElement-&amp;gt;FirstChildElement(&quot;v&quot;);
            if (vElement)
            {
                v = vElement-&amp;gt;GetText();
            }
            if (rowArray.size() &amp;lt; colIndex)
            {
                int len = rowArray.size();
                for (auto i = 0;i &amp;lt; colIndex - len;i++)
                {
                    rowArray.push_back(&quot;&quot;); //
                }
            }
            if (t == &quot;s&quot;)
            {
                rowArray.push_back(valueArray[atoi(v.c_str())]);
            }
            else
            {
                rowArray.push_back(v);
            }
            cElement = cElement-&amp;gt;NextSiblingElement(&quot;c&quot;);
        }
        auto bb = false;
        for (auto iii : rowArray)
        {
            if (iii.length() &amp;gt; 1)
            {
                bb = true;
                break;
            }
        }
        if (bb)
        {
            excelHash[rowIndex] = lineInfo;
        }
        rowElement = rowElement-&amp;gt;NextSiblingElement(&quot;row&quot;);
    }
    return true;
}

std::vector&amp;lt;std::string&amp;gt; Excel::_getValueArray()
{
    std::vector&amp;lt;std::string&amp;gt; result;
    
    ssize_t size;
    auto fileData = getFileDataFromZip(_excelFilePath,  &quot;xl/sharedStrings.xml&quot;, &amp;amp;size);
	    
    tinyxml2::XMLDocument doc;
    doc.Parse((const char*)fileData,size);
    XMLElement *root = doc.RootElement();
    XMLElement *siElement = root-&amp;gt;FirstChildElement(&quot;si&quot;);
    
    while (siElement)
    {
        std::string temp = &quot;&quot;;
        auto tElement = siElement-&amp;gt;FirstChildElement(&quot;t&quot;);
        while (tElement)
        {
            temp = temp + tElement-&amp;gt;GetText();
            tElement = tElement-&amp;gt;NextSiblingElement(&quot;t&quot;);
        }
        result.push_back(temp);
        siElement = siElement-&amp;gt;NextSiblingElement(&quot;si&quot;);
    }
    return result;
}

std::vector&amp;lt;LineInfo&amp;gt; Excel::getSheetArray()
{
    std::vector&amp;lt;LineInfo&amp;gt; result;
    for ( auto ite = excelHash.begin();ite != excelHash.end();ite++)
    {
        auto &amp;amp;lineInfo_ = ite-&amp;gt;second;
        result.push_back(lineInfo_);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 13 Jul 2015 21:21:00 +0800</pubDate>
        <link>http://haroel.github.io/i/c/c++/cocos/2015/07/13/cpp-excel.html</link>
        <guid isPermaLink="true">http://haroel.github.io/i/c/c++/cocos/2015/07/13/cpp-excel.html</guid>
        
        
        <category>c/c++</category>
        
        <category>cocos</category>
        
      </item>
    
      <item>
        <title>C++ 中list、vector和deque比较</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;转自 &lt;a href=&quot;http://blog.csdn.net/xiaolajiao8787/article/details/5882609&quot;&gt;http://blog.csdn.net/xiaolajiao8787/article/details/5882609&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;性能比较&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;Vector&lt;/th&gt;
      &lt;th&gt;Deque&lt;/th&gt;
      &lt;th&gt;List&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;内存管理&lt;/td&gt;
      &lt;td&gt;Poor&lt;/td&gt;
      &lt;td&gt;Good&lt;/td&gt;
      &lt;td&gt;perfect&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用[ ]和at() 操作访问数据&lt;/td&gt;
      &lt;td&gt;Very good&lt;/td&gt;
      &lt;td&gt;Normal&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Iterator的访问速度&lt;/td&gt;
      &lt;td&gt;Good&lt;/td&gt;
      &lt;td&gt;Very good&lt;/td&gt;
      &lt;td&gt;Good&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Push_back操作（后插入）&lt;/td&gt;
      &lt;td&gt;Good&lt;/td&gt;
      &lt;td&gt;Good&lt;/td&gt;
      &lt;td&gt;Good&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Push_front操作（前插入）&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;Very good&lt;/td&gt;
      &lt;td&gt;Good&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Insert（中间插入）&lt;/td&gt;
      &lt;td&gt;Poor&lt;/td&gt;
      &lt;td&gt;Perfect&lt;/td&gt;
      &lt;td&gt;Perfect&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Erase（中间删除）&lt;/td&gt;
      &lt;td&gt;Poor&lt;/td&gt;
      &lt;td&gt;Perfect&lt;/td&gt;
      &lt;td&gt;Perfect&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Pop_back（后部删除）&lt;/td&gt;
      &lt;td&gt;Perfect&lt;/td&gt;
      &lt;td&gt;Perfect&lt;/td&gt;
      &lt;td&gt;Normal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Swap（交换数据）&lt;/td&gt;
      &lt;td&gt;Perfect&lt;/td&gt;
      &lt;td&gt;Very good&lt;/td&gt;
      &lt;td&gt;Good&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;遍历&lt;/td&gt;
      &lt;td&gt;Perfect&lt;/td&gt;
      &lt;td&gt;Good&lt;/td&gt;
      &lt;td&gt;Normal&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Fri, 19 Sep 2014 21:45:00 +0800</pubDate>
        <link>http://haroel.github.io/i/c/c++/2014/09/19/stl-container.html</link>
        <guid isPermaLink="true">http://haroel.github.io/i/c/c++/2014/09/19/stl-container.html</guid>
        
        
        <category>c/c++</category>
        
      </item>
    
      <item>
        <title>cocos2d-x android项目引用so库编译</title>
        <description>&lt;p&gt;项目接了几十个渠道平台，每个平台都建了一个Android工程，引用Classes，由于才用java接口类来抽象出平台接口方法，所以每个工程的Android.mk是完全一致的，也就是说libgame.so是一样的。前期为了保证开发进度，没有做优化，所以发一次版本，几十个渠道都要编译一次c++，其过程之痛苦，令人不寒而栗！&lt;/p&gt;

&lt;p&gt;　　想办法来优化发布过程，思路是这样的，A工程先正确的编译一次，得到一个libgame.so库文件，然后B工程里面，我们在jni目录下新建目录prebuilt，然后把libgame.so放上去，Android,mk修改成如下内容，这样，B工程根本毋须编译任何c++代码，速度提升了N倍　　
　　　
#####以下为MK配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　		　	
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := game
LOCAL_SRC_FILES := prebuilt/libgame.so
include $(PREBUILT_SHARED_LIBRARY 

LOCAL_SHARED_LIBRARIES := game
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　clean，然后编译，你将体会这种做法带来的便利.当然这么做的前提是你的安卓项目里面没有使用宏处理编译。
　　&lt;/p&gt;

</description>
        <pubDate>Fri, 19 Sep 2014 21:45:00 +0800</pubDate>
        <link>http://haroel.github.io/i/cocos/android/2014/09/19/cocos2dxandroidsolib.html</link>
        <guid isPermaLink="true">http://haroel.github.io/i/cocos/android/2014/09/19/cocos2dxandroidsolib.html</guid>
        
        
        <category>cocos</category>
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>Hello Github page</title>
        <description>&lt;h4 id=&quot;haroelgithubioihttpharoelgithubioi--&quot;&gt;今后，个人技术博客将迁移到&lt;a href=&quot;http://haroel.github.io/i&quot;&gt;haroel.github.io/i&lt;/a&gt; ，:-)&lt;/h4&gt;

</description>
        <pubDate>Fri, 19 Sep 2014 21:30:00 +0800</pubDate>
        <link>http://haroel.github.io/i/%E5%85%B6%E4%BB%96/2014/09/19/sayhey.html</link>
        <guid isPermaLink="true">http://haroel.github.io/i/%E5%85%B6%E4%BB%96/2014/09/19/sayhey.html</guid>
        
        
        <category>其他</category>
        
      </item>
    
  </channel>
</rss>
